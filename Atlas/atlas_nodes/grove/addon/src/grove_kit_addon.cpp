/* ----------------------------------------------------------------------------
 * This file was automatically generated by io-js-autogen Version 0.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify the
 * C header file instead.
 * ----------------------------------------------------------------------------- */
#include "grove_kit_addon.h"
#include "stdlib.h"
#include "string.h"
#include "_globalvar.h"

using namespace v8;


// 25: extern int rotaryInit ( rotaryConfig config , rotaryDegreeCb degCb , rotaryThreCb threCb ) ;
Handle<Value> rotaryInitV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_aioPin = args[0]->ToObject()->Get(String::New("aioPin"));
    V8_ASSERT(!args0_aioPin->IsNull() && args0_aioPin->IsInt32(), "arg0.aioPin parameter error");
    int arg0_aioPin = (int)args0_aioPin->IntegerValue();
    
    Local<Value> args0_interval = args[0]->ToObject()->Get(String::New("interval"));
    V8_ASSERT(!args0_interval->IsNull() && args0_interval->IsInt32(), "arg0.interval parameter error");
    int arg0_interval = (int)args0_interval->IntegerValue();
    
    Local<Value> args0_threshold = args[0]->ToObject()->Get(String::New("threshold"));
    V8_ASSERT(!args0_threshold->IsNull() && args0_threshold->IsInt32(), "arg0.threshold parameter error");
    int arg0_threshold = (int)args0_threshold->IntegerValue();
    
    rotaryConfig arg0;
    arg0.aioPin = arg0_aioPin;
    arg0.interval = arg0_interval;
    arg0.threshold = arg0_threshold;
    
    
    V8_ASSERT(args[1]->IsFunction(), "args[1] parameters error!");
    cbArray[0] = Persistent<Function>::New(Local<Function>::Cast(args[1]));
    rotaryDegreeCb arg1;;
    arg1 = cbFunc0;
    
    
    V8_ASSERT(args[2]->IsFunction(), "args[2] parameters error!");
    cbArray[1] = Persistent<Function>::New(Local<Function>::Cast(args[2]));
    rotaryThreCb arg2;;
    arg2 = cbFunc1;
    
        
    // Call C++ function
    int ret = (int)rotaryInit(arg0, arg1, arg2);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 26: extern int rotaryRelease ( ) ;
Handle<Value> rotaryReleaseV8(const Arguments &args) {
    HandleScope scope;
        
    // Call C++ function
    int ret = (int)rotaryRelease();
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 27: extern int rotaryOnData ( int toggle ) ;
Handle<Value> rotaryOnDataV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsInt32(), "args[0] parameters error!");
    int arg0 = (int)args[0]->IntegerValue();
    
        
    // Call C++ function
    int ret = (int)rotaryOnData(arg0);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 42: extern int relayInit ( relayConfig config , relayCb cb ) ;
Handle<Value> relayInitV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_pin = args[0]->ToObject()->Get(String::New("pin"));
    V8_ASSERT(!args0_pin->IsNull() && args0_pin->IsInt32(), "arg0.pin parameter error");
    int arg0_pin = (int)args0_pin->IntegerValue();
    
    relayConfig arg0;
    arg0.pin = arg0_pin;
    
    
    V8_ASSERT(args[1]->IsFunction(), "args[1] parameters error!");
    cbArray[2] = Persistent<Function>::New(Local<Function>::Cast(args[1]));
    relayCb arg1;;
    arg1 = cbFunc2;
    
        
    // Call C++ function
    int ret = (int)relayInit(arg0, arg1);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 43: extern int relayRelease ( ) ;
Handle<Value> relayReleaseV8(const Arguments &args) {
    HandleScope scope;
        
    // Call C++ function
    int ret = (int)relayRelease();
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 44: extern int relayOnData ( int toggle ) ;
Handle<Value> relayOnDataV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsInt32(), "args[0] parameters error!");
    int arg0 = (int)args[0]->IntegerValue();
    
        
    // Call C++ function
    int ret = (int)relayOnData(arg0);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
static void SetMemberFunc(Handle<Object> obj) {
    obj->Set(v8::String::NewSymbol("rotaryInit"),
           FunctionTemplate::New(rotaryInitV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("rotaryRelease"),
           FunctionTemplate::New(rotaryReleaseV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("rotaryOnData"),
           FunctionTemplate::New(rotaryOnDataV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("relayInit"),
           FunctionTemplate::New(relayInitV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("relayRelease"),
           FunctionTemplate::New(relayReleaseV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("relayOnData"),
           FunctionTemplate::New(relayOnDataV8)->GetFunction());
}


// Const defined by macros
static void SetConst(Handle<Object> obj) {

    obj->Set(v8::String::NewSymbol("ERR_NONE"),
             Int32::New(0));

    obj->Set(v8::String::NewSymbol("ERR_UNKOWN"),
             Int32::New(-1));

    obj->Set(v8::String::NewSymbol("rotaryClass"),
             v8::String::New("grove"));

    obj->Set(v8::String::NewSymbol("rotaryConfig_aioPin"),
             Int32::New(0));

    obj->Set(v8::String::NewSymbol("rotaryConfig_interval"),
             Int32::New(300));

    obj->Set(v8::String::NewSymbol("rotaryConfig_threshold"),
             Int32::New(150));

    obj->Set(v8::String::NewSymbol("relayClass"),
             v8::String::New("grove"));

    obj->Set(v8::String::NewSymbol("relayConfig_pin"),
             Int32::New(0));

}

// Const defined by enumeration
static void SetEnumConst(Handle<Object> obj) {

}
static void SetGlobalVarFunc(Handle<Object> obj) {
}

void Initgrove_kit(Handle<Object> exports) {

    SetMemberFunc(exports);

    SetConst(exports);

    SetEnumConst(exports);

    SetGlobalVarFunc(exports);
}
