/* ----------------------------------------------------------------------------
 * This file was automatically generated by io-js-autogen Version 0.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify the
 * C header file instead.
 * ----------------------------------------------------------------------------- */
#include "cv_atlas_addon.h"
#include "stdlib.h"
#include "string.h"
#include "_globalvar.h"

using namespace v8;


// 33: extern int cameraInit ( cameraConfig config , cameraCb cb ) ;
Handle<Value> cameraInitV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_interval = args[0]->ToObject()->Get(String::New("interval"));
    V8_ASSERT(!args0_interval->IsNull() && args0_interval->IsInt32(), "arg0.interval parameter error");
    int arg0_interval = (int)args0_interval->IntegerValue();
    
    Local<Value> args0_camId = args[0]->ToObject()->Get(String::New("camId"));
    V8_ASSERT(!args0_camId->IsNull() && args0_camId->IsInt32(), "arg0.camId parameter error");
    int arg0_camId = (int)args0_camId->IntegerValue();
    
    Local<Value> args0_width = args[0]->ToObject()->Get(String::New("width"));
    V8_ASSERT(!args0_width->IsNull() && args0_width->IsInt32(), "arg0.width parameter error");
    int arg0_width = (int)args0_width->IntegerValue();
    
    Local<Value> args0_height = args[0]->ToObject()->Get(String::New("height"));
    V8_ASSERT(!args0_height->IsNull() && args0_height->IsInt32(), "arg0.height parameter error");
    int arg0_height = (int)args0_height->IntegerValue();
    
    cameraConfig arg0;
    arg0.interval = arg0_interval;
    arg0.camId = arg0_camId;
    arg0.width = arg0_width;
    arg0.height = arg0_height;
    
    
    V8_ASSERT(args[1]->IsFunction(), "args[1] parameters error!");
    cbArray[1] = Persistent<Function>::New(Local<Function>::Cast(args[1]));
    cameraCb arg1;;
    arg1 = cbFunc1;
    
        
    // Call C++ function
    int ret = (int)cameraInit(arg0, arg1);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 34: extern int cameraRelease ( ) ;
Handle<Value> cameraReleaseV8(const Arguments &args) {
    HandleScope scope;
        
    // Call C++ function
    int ret = (int)cameraRelease();
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 35: extern int cameraOnData ( int toggle ) ;
Handle<Value> cameraOnDataV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsInt32(), "args[0] parameters error!");
    int arg0 = (int)args[0]->IntegerValue();
    
        
    // Call C++ function
    int ret = (int)cameraOnData(arg0);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 59: extern int faceDetectInit ( faceDetectConfig config , faceDetectNumCb ncb , faceDetectImgCb icb , faceDetectAllCb acb ) ;
Handle<Value> faceDetectInitV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_imgWidth = args[0]->ToObject()->Get(String::New("imgWidth"));
    V8_ASSERT(!args0_imgWidth->IsNull() && args0_imgWidth->IsInt32(), "arg0.imgWidth parameter error");
    int arg0_imgWidth = (int)args0_imgWidth->IntegerValue();
    
    Local<Value> args0_imgHeight = args[0]->ToObject()->Get(String::New("imgHeight"));
    V8_ASSERT(!args0_imgHeight->IsNull() && args0_imgHeight->IsInt32(), "arg0.imgHeight parameter error");
    int arg0_imgHeight = (int)args0_imgHeight->IntegerValue();
    
    Local<Value> args0_faceWidth = args[0]->ToObject()->Get(String::New("faceWidth"));
    V8_ASSERT(!args0_faceWidth->IsNull() && args0_faceWidth->IsInt32(), "arg0.faceWidth parameter error");
    int arg0_faceWidth = (int)args0_faceWidth->IntegerValue();
    
    Local<Value> args0_faceHeight = args[0]->ToObject()->Get(String::New("faceHeight"));
    V8_ASSERT(!args0_faceHeight->IsNull() && args0_faceHeight->IsInt32(), "arg0.faceHeight parameter error");
    int arg0_faceHeight = (int)args0_faceHeight->IntegerValue();
    
    faceDetectConfig arg0;
    arg0.imgWidth = arg0_imgWidth;
    arg0.imgHeight = arg0_imgHeight;
    arg0.faceWidth = arg0_faceWidth;
    arg0.faceHeight = arg0_faceHeight;
    
    
    V8_ASSERT(args[1]->IsFunction(), "args[1] parameters error!");
    cbArray[2] = Persistent<Function>::New(Local<Function>::Cast(args[1]));
    faceDetectNumCb arg1;;
    arg1 = cbFunc2;
    
    
    V8_ASSERT(args[2]->IsFunction(), "args[2] parameters error!");
    cbArray[3] = Persistent<Function>::New(Local<Function>::Cast(args[2]));
    faceDetectImgCb arg2;;
    arg2 = cbFunc3;
    
    
    V8_ASSERT(args[3]->IsFunction(), "args[3] parameters error!");
    cbArray[4] = Persistent<Function>::New(Local<Function>::Cast(args[3]));
    faceDetectAllCb arg3;;
    arg3 = cbFunc4;
    
        
    // Call C++ function
    int ret = (int)faceDetectInit(arg0, arg1, arg2, arg3);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 61: extern int faceDetectOnData ( faceDetectConfig config , unsigned long imgHandle ) ;
Handle<Value> faceDetectOnDataV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_imgWidth = args[0]->ToObject()->Get(String::New("imgWidth"));
    V8_ASSERT(!args0_imgWidth->IsNull() && args0_imgWidth->IsInt32(), "arg0.imgWidth parameter error");
    int arg0_imgWidth = (int)args0_imgWidth->IntegerValue();
    
    Local<Value> args0_imgHeight = args[0]->ToObject()->Get(String::New("imgHeight"));
    V8_ASSERT(!args0_imgHeight->IsNull() && args0_imgHeight->IsInt32(), "arg0.imgHeight parameter error");
    int arg0_imgHeight = (int)args0_imgHeight->IntegerValue();
    
    Local<Value> args0_faceWidth = args[0]->ToObject()->Get(String::New("faceWidth"));
    V8_ASSERT(!args0_faceWidth->IsNull() && args0_faceWidth->IsInt32(), "arg0.faceWidth parameter error");
    int arg0_faceWidth = (int)args0_faceWidth->IntegerValue();
    
    Local<Value> args0_faceHeight = args[0]->ToObject()->Get(String::New("faceHeight"));
    V8_ASSERT(!args0_faceHeight->IsNull() && args0_faceHeight->IsInt32(), "arg0.faceHeight parameter error");
    int arg0_faceHeight = (int)args0_faceHeight->IntegerValue();
    
    faceDetectConfig arg0;
    arg0.imgWidth = arg0_imgWidth;
    arg0.imgHeight = arg0_imgHeight;
    arg0.faceWidth = arg0_faceWidth;
    arg0.faceHeight = arg0_faceHeight;
    
    
    V8_ASSERT(args[1]->IsNumber(), "args[1] parameters error!");
    unsigned long arg1 = (unsigned long)args[1]->NumberValue();
    
        
    // Call C++ function
    int ret = (int)faceDetectOnData(arg0, arg1);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 62: extern int faceDetectRelease ( ) ;
Handle<Value> faceDetectReleaseV8(const Arguments &args) {
    HandleScope scope;
        
    // Call C++ function
    int ret = (int)faceDetectRelease();
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 82: extern int img2Base64Init ( img2Base64Config config , img2Base64Cb cb ) ;
Handle<Value> img2Base64InitV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_imgType = args[0]->ToObject()->Get(String::New("imgType"));
    V8_ASSERT(!args0_imgType->IsNull() && (args0_imgType->IsString() || args0_imgType->IsObject()), "arg0.imgType parameter error");
    char *arg0_imgType;
    int idx0_0;
    int len0_0;
    if (args0_imgType->IsString()) {
        v8::String::AsciiValue args0_imgType_at(args0_imgType->ToString());
        len0_0 = strlen(*args0_imgType_at) + 1;
        arg0_imgType = new char[len0_0];
        strcpy(arg0_imgType, *args0_imgType_at);
    } else {
        Local<Array> args0_imgType_at = Local<Array>::Cast(args0_imgType);
        len0_0 = args0_imgType_at->Length() + 1;
        arg0_imgType = new char[len0_0];
        for (idx0_0 = 0; idx0_0 < len0_0 - 1; idx0_0++) {
            Local<Value> args0_imgType_a = args0_imgType_at->Get(idx0_0);
            V8_ASSERT(!args0_imgType_a->IsNull() && args0_imgType_a->IsInt32(), "arg0_imgType[%d] parameter error", idx0_0);
            arg0_imgType[idx0_0] = (char)args0_imgType_a->IntegerValue();
        }
        arg0_imgType[idx0_0] = 0;
    }
    
    Local<Value> args0_quality = args[0]->ToObject()->Get(String::New("quality"));
    V8_ASSERT(!args0_quality->IsNull() && args0_quality->IsInt32(), "arg0.quality parameter error");
    int arg0_quality = (int)args0_quality->IntegerValue();
    
    Local<Value> args0_maxWidth = args[0]->ToObject()->Get(String::New("maxWidth"));
    V8_ASSERT(!args0_maxWidth->IsNull() && args0_maxWidth->IsInt32(), "arg0.maxWidth parameter error");
    int arg0_maxWidth = (int)args0_maxWidth->IntegerValue();
    
    Local<Value> args0_maxHeight = args[0]->ToObject()->Get(String::New("maxHeight"));
    V8_ASSERT(!args0_maxHeight->IsNull() && args0_maxHeight->IsInt32(), "arg0.maxHeight parameter error");
    int arg0_maxHeight = (int)args0_maxHeight->IntegerValue();
    
    img2Base64Config arg0;
    arg0.imgType = new char[sizeof(arg0_imgType)/sizeof(arg0_imgType[0])];
    strcpy(arg0.imgType, arg0_imgType);
    delete [] arg0_imgType;
    arg0.quality = arg0_quality;
    arg0.maxWidth = arg0_maxWidth;
    arg0.maxHeight = arg0_maxHeight;
    
    
    V8_ASSERT(args[1]->IsFunction(), "args[1] parameters error!");
    cbArray[5] = Persistent<Function>::New(Local<Function>::Cast(args[1]));
    img2Base64Cb arg1;;
    arg1 = cbFunc5;
    
        
    // Call C++ function
    int ret = (int)img2Base64Init(arg0, arg1);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 83: extern int img2Base64OnData ( img2Base64Config config , unsigned long imgHandle ) ;
Handle<Value> img2Base64OnDataV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_imgType = args[0]->ToObject()->Get(String::New("imgType"));
    V8_ASSERT(!args0_imgType->IsNull() && (args0_imgType->IsString() || args0_imgType->IsObject()), "arg0.imgType parameter error");
    char *arg0_imgType;
    int idx0_0;
    int len0_0;
    if (args0_imgType->IsString()) {
        v8::String::AsciiValue args0_imgType_at(args0_imgType->ToString());
        len0_0 = strlen(*args0_imgType_at) + 1;
        arg0_imgType = new char[len0_0];
        strcpy(arg0_imgType, *args0_imgType_at);
    } else {
        Local<Array> args0_imgType_at = Local<Array>::Cast(args0_imgType);
        len0_0 = args0_imgType_at->Length() + 1;
        arg0_imgType = new char[len0_0];
        for (idx0_0 = 0; idx0_0 < len0_0 - 1; idx0_0++) {
            Local<Value> args0_imgType_a = args0_imgType_at->Get(idx0_0);
            V8_ASSERT(!args0_imgType_a->IsNull() && args0_imgType_a->IsInt32(), "arg0_imgType[%d] parameter error", idx0_0);
            arg0_imgType[idx0_0] = (char)args0_imgType_a->IntegerValue();
        }
        arg0_imgType[idx0_0] = 0;
    }
    
    Local<Value> args0_quality = args[0]->ToObject()->Get(String::New("quality"));
    V8_ASSERT(!args0_quality->IsNull() && args0_quality->IsInt32(), "arg0.quality parameter error");
    int arg0_quality = (int)args0_quality->IntegerValue();
    
    Local<Value> args0_maxWidth = args[0]->ToObject()->Get(String::New("maxWidth"));
    V8_ASSERT(!args0_maxWidth->IsNull() && args0_maxWidth->IsInt32(), "arg0.maxWidth parameter error");
    int arg0_maxWidth = (int)args0_maxWidth->IntegerValue();
    
    Local<Value> args0_maxHeight = args[0]->ToObject()->Get(String::New("maxHeight"));
    V8_ASSERT(!args0_maxHeight->IsNull() && args0_maxHeight->IsInt32(), "arg0.maxHeight parameter error");
    int arg0_maxHeight = (int)args0_maxHeight->IntegerValue();
    
    img2Base64Config arg0;
    arg0.imgType = new char[sizeof(arg0_imgType)/sizeof(arg0_imgType[0])];
    strcpy(arg0.imgType, arg0_imgType);
    delete [] arg0_imgType;
    arg0.quality = arg0_quality;
    arg0.maxWidth = arg0_maxWidth;
    arg0.maxHeight = arg0_maxHeight;
    
    
    V8_ASSERT(args[1]->IsNumber(), "args[1] parameters error!");
    unsigned long arg1 = (unsigned long)args[1]->NumberValue();
    
        
    // Call C++ function
    int ret = (int)img2Base64OnData(arg0, arg1);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
// 84: extern int img2Base64Release ( img2Base64Config config ) ;
Handle<Value> img2Base64ReleaseV8(const Arguments &args) {
    HandleScope scope;
    
    // Convert V8 parameters to C++
    
    V8_ASSERT(args[0]->IsObject(), "args[0] parameters error!");
    Local<Value> args0_imgType = args[0]->ToObject()->Get(String::New("imgType"));
    V8_ASSERT(!args0_imgType->IsNull() && (args0_imgType->IsString() || args0_imgType->IsObject()), "arg0.imgType parameter error");
    char *arg0_imgType;
    int idx0_0;
    int len0_0;
    if (args0_imgType->IsString()) {
        v8::String::AsciiValue args0_imgType_at(args0_imgType->ToString());
        len0_0 = strlen(*args0_imgType_at) + 1;
        arg0_imgType = new char[len0_0];
        strcpy(arg0_imgType, *args0_imgType_at);
    } else {
        Local<Array> args0_imgType_at = Local<Array>::Cast(args0_imgType);
        len0_0 = args0_imgType_at->Length() + 1;
        arg0_imgType = new char[len0_0];
        for (idx0_0 = 0; idx0_0 < len0_0 - 1; idx0_0++) {
            Local<Value> args0_imgType_a = args0_imgType_at->Get(idx0_0);
            V8_ASSERT(!args0_imgType_a->IsNull() && args0_imgType_a->IsInt32(), "arg0_imgType[%d] parameter error", idx0_0);
            arg0_imgType[idx0_0] = (char)args0_imgType_a->IntegerValue();
        }
        arg0_imgType[idx0_0] = 0;
    }
    
    Local<Value> args0_quality = args[0]->ToObject()->Get(String::New("quality"));
    V8_ASSERT(!args0_quality->IsNull() && args0_quality->IsInt32(), "arg0.quality parameter error");
    int arg0_quality = (int)args0_quality->IntegerValue();
    
    Local<Value> args0_maxWidth = args[0]->ToObject()->Get(String::New("maxWidth"));
    V8_ASSERT(!args0_maxWidth->IsNull() && args0_maxWidth->IsInt32(), "arg0.maxWidth parameter error");
    int arg0_maxWidth = (int)args0_maxWidth->IntegerValue();
    
    Local<Value> args0_maxHeight = args[0]->ToObject()->Get(String::New("maxHeight"));
    V8_ASSERT(!args0_maxHeight->IsNull() && args0_maxHeight->IsInt32(), "arg0.maxHeight parameter error");
    int arg0_maxHeight = (int)args0_maxHeight->IntegerValue();
    
    img2Base64Config arg0;
    arg0.imgType = new char[sizeof(arg0_imgType)/sizeof(arg0_imgType[0])];
    strcpy(arg0.imgType, arg0_imgType);
    delete [] arg0_imgType;
    arg0.quality = arg0_quality;
    arg0.maxWidth = arg0_maxWidth;
    arg0.maxHeight = arg0_maxHeight;
    
        
    // Call C++ function
    int ret = (int)img2Base64Release(arg0);
    
    
    
    // Convert C++ return value to V8
    Handle<Value> retV8 = Int32::New(ret);
    
    return scope.Close(retV8);
    
}
static void SetMemberFunc(Handle<Object> obj) {
    obj->Set(v8::String::NewSymbol("cameraInit"),
           FunctionTemplate::New(cameraInitV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("cameraRelease"),
           FunctionTemplate::New(cameraReleaseV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("cameraOnData"),
           FunctionTemplate::New(cameraOnDataV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("faceDetectInit"),
           FunctionTemplate::New(faceDetectInitV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("faceDetectOnData"),
           FunctionTemplate::New(faceDetectOnDataV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("faceDetectRelease"),
           FunctionTemplate::New(faceDetectReleaseV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("img2Base64Init"),
           FunctionTemplate::New(img2Base64InitV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("img2Base64OnData"),
           FunctionTemplate::New(img2Base64OnDataV8)->GetFunction());

    obj->Set(v8::String::NewSymbol("img2Base64Release"),
           FunctionTemplate::New(img2Base64ReleaseV8)->GetFunction());
}


// Const defined by macros
static void SetConst(Handle<Object> obj) {

    obj->Set(v8::String::NewSymbol("ERR_NONE"),
             Int32::New(0));

    obj->Set(v8::String::NewSymbol("ERR_UNKOWN"),
             Int32::New(-1));

    obj->Set(v8::String::NewSymbol("ERR_NO_CAMERA"),
             Int32::New(-2));

    obj->Set(v8::String::NewSymbol("ERR_NO_FACE_CASCADE"),
             Int32::New(-3));

    obj->Set(v8::String::NewSymbol("ERR_OVER_SIZE"),
             Int32::New(-4));

    obj->Set(v8::String::NewSymbol("ERR_SINGLE_INSTANCE"),
             Int32::New(-5));

    obj->Set(v8::String::NewSymbol("cameraClass"),
             v8::String::New("CV"));

    obj->Set(v8::String::NewSymbol("cameraConfig_interval"),
             Int32::New(500));

    obj->Set(v8::String::NewSymbol("cameraConfig_camId"),
             Int32::New(-1));

    obj->Set(v8::String::NewSymbol("cameraConfig_width"),
             Int32::New(160));

    obj->Set(v8::String::NewSymbol("cameraConfig_height"),
             Int32::New(120));

    obj->Set(v8::String::NewSymbol("faceDetectClass"),
             v8::String::New("CV"));

    obj->Set(v8::String::NewSymbol("faceDetectConfig_imgWidth"),
             Int32::New(128));

    obj->Set(v8::String::NewSymbol("faceDetectConfig_imgHeight"),
             Int32::New(96));

    obj->Set(v8::String::NewSymbol("faceDetectConfig_faceWidth"),
             Int32::New(30));

    obj->Set(v8::String::NewSymbol("faceDetectConfig_faceHeight"),
             Int32::New(30));

    obj->Set(v8::String::NewSymbol("img2Base64Class"),
             v8::String::New("CV"));

    obj->Set(v8::String::NewSymbol("img2Base64Config_imgType"),
             v8::String::New("jpg"));

    obj->Set(v8::String::NewSymbol("img2Base64Config_quality"),
             Int32::New(70));

    obj->Set(v8::String::NewSymbol("img2Base64Config_maxWidth"),
             Int32::New(1280));

    obj->Set(v8::String::NewSymbol("img2Base64Config_maxHeight"),
             Int32::New(720));

}

// Const defined by enumeration
static void SetEnumConst(Handle<Object> obj) {

}
static void SetGlobalVarFunc(Handle<Object> obj) {
}

void Initcv_atlas(Handle<Object> exports) {

    SetMemberFunc(exports);

    SetConst(exports);

    SetEnumConst(exports);

    SetGlobalVarFunc(exports);
}
